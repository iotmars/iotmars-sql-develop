# 前言

传统ssm项目有繁琐又模板式的跳转（controller->service-mapper）,本项目的原意是省略这些模板式的跳转，直接写sql实现功能的开发。一些简单的查询sql可以由系统自动生成然后拼接。这样连sql语句这一步都省略了。希望本项目可以让拧螺丝的您感到快乐和轻松。

# 项目结构

本项目分为两个模块：sql-devlop和sql-devlop-demo

其中 sql-devlop-demo仅仅是用来告诉您怎么使用该项目，仅仅是个示例。项目的唯一核心是sql-devlop。

# 如何使用该项目

首先用mvn install命令install项目sql-devlop到本地仓库。 

当打开项目sql-devlop-demo的pom.xml后，您可以看到如下的代码：

```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.0.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.marssenger</groupId>
    <artifactId>sql-develop-demo</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <spring-cloud.version>Hoxton.SR1</spring-cloud.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>
        <dependency>
            <groupId>com.marssenger</groupId>
            <artifactId>sql-develop</artifactId>
            <version>0.0.12-SNAPSHOT</version>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-web</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-autoconfigure</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-beans</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-core</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.slf4j</groupId>
                    <artifactId>slf4j-api</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

</project>
```

您可以看出来，这是一个普通的springboot项目，引入了sql-develop模块，并排除了一些包。这些包是spring-boot-starter-web，spring-boot-starter，spring-boot-autoconfigure，spring-beans，spring-core，slf4j-api等，这些仅仅是因为您的项目的springboot版本可能与我这个项目的springboot版本不一致。如果您的项目和我的项目有更多的包冲突，请您手动排除相应依赖。

现在您可以找一个数据库，执行如下脚本:

```
CREATE TABLE `cc_base_sql` (
  `sql_code` varchar(64) NOT NULL,
  `sql_type` varchar(12) NOT NULL DEFAULT 'select' COMMENT 'insert,delete,update,select',
  `sql` text NOT NULL COMMENT '具体的sql语句',
  `total_sql` varchar(2550) DEFAULT NULL COMMENT '分页所对应的总数sql',
  `sql_result_name` varchar(64) DEFAULT NULL COMMENT 'sql所对应的返回结果的名字',
  `total_sql_result_name` varchar(64) DEFAULT NULL COMMENT '总数所对应的结果的名字',
  `jexl` varchar(2550) DEFAULT NULL COMMENT 'java表达式（待扩展）',
  `map` varchar(2550) DEFAULT NULL COMMENT 'sql运行的上下文',
  `order_no` int(11) DEFAULT NULL COMMENT '排序号',
  `remark` varchar(200) DEFAULT NULL COMMENT 'sql的说明',
  PRIMARY KEY (`sql_code`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
CREATE TABLE `cc_base_sql_series` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `series_code` varchar(64) NOT NULL,
  `sql_code` varchar(64) NOT NULL,
  `identifier` varchar(64) DEFAULT NULL COMMENT '结果的标识符',
  `order_no` int(11) DEFAULT NULL COMMENT '排序号',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `idx_sql_code` (`sql_code`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=59 DEFAULT CHARSET=utf8mb4;
```

其中cc_base_sql是用来根据sql_code查到一条sql来执行。cc_base_sql_series是用来根据series_code查到一系列sql来按照顺序执行。

最后一步，您打开bootstrap-dev.yml，引入您的数据库配置。bootstrap-dev.yml里仅仅是普通的yml配置，因为项目最基本的是数据库，如果您不需要springcloud的注册中心的繁琐配置，您可以单纯参考一般的springboot项目引入mysql数据库的写法，不再赘述。

数据源配置好后，您可以运行一个这个sql-devlop-demo项目。

项目运行后，一切都大功告成。

# 使用浏览器访问该项目

您打开sql-devlop的StandardController.java，可以看到如下代码

```
@RestController
@RequestMapping("/common/standard/sql")
public class StandardController {

    @Autowired
    private StandardSqlService cardListService;


    /**
     * 复杂的查询
     *
     * @param sqlCode
     * @param seriesCode
     * @param params
     * @param handler
     * @param handlerType
     * @param handlerParams
     * @param executor
     * @param executorType
     * @param executorParams
     * @param resultType
     * @param route
     * @return
     */
    @RequestMapping("/list")
    public Object getList(@RequestParam(required = false) String sqlCode, @RequestParam(required = false) String seriesCode, @RequestParam Map<String, Object> params,
                          @RequestParam(required = false) String handler, @RequestParam(defaultValue = StandardQueryObject.BEAN) String handlerType, @RequestParam(required = false) String handlerParams,
                          @RequestParam(required = false) String executor, @RequestParam(defaultValue = StandardQueryObject.BEAN) String executorType, @RequestParam(required = false) String executorParams,
                          @RequestParam(defaultValue = "list") String resultType, @RequestParam(required = false) String route) {
        if (StringUtils.isEmpty(sqlCode) && StringUtils.isEmpty(seriesCode)) {
            throw new RuntimeException("sqlCode和seriesCode不能同时为空");
        }
        StandardQueryObject standardQueryObject = new StandardQueryObject();
        standardQueryObject.setParams(params);
        DatabaseSqlProvider provider = new DatabaseSqlProvider();
        provider.setSqlCode(sqlCode);
        provider.setSeriesCode(seriesCode);
        standardQueryObject.setSqlProvider(provider);
        standardQueryObject.setResultType(resultType);
        standardQueryObject.setHandler(handler);
        standardQueryObject.setHandlerType(handlerType);
        standardQueryObject.setHandlerParams(handlerParams);
        standardQueryObject.setExecutor(executor);
        standardQueryObject.setExecutorType(executorType);
        standardQueryObject.setExecutorParams(executorParams);
        standardQueryObject.setRoute(route);
        try {
            Object result = cardListService.getResult(standardQueryObject);
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return AjaxResult.error(e.getMessage());
        }
    }

    /**
     * 单表查询
     *
     * @param params
     * @param handler
     * @param handlerType
     * @param handlerParams
     * @param executor
     * @param executorType
     * @param executorParams
     * @param resultType
     * @param route
     * @return
     */
    @RequestMapping("/selectOneTable")
    public Object selectOneTable(
            @RequestParam Map<String, Object> params,
            @RequestParam(required = false) String handler, @RequestParam(defaultValue = StandardQueryObject.BEAN) String handlerType, @RequestParam(required = false) String handlerParams,
            @RequestParam(required = false) String executor, @RequestParam(defaultValue = StandardQueryObject.BEAN) String executorType, @RequestParam(required = false) String executorParams,
            @RequestParam(defaultValue = "list") String resultType, @RequestParam(required = false) String route) {
        R1SqlProvider r1SqlProvider = new R1SqlProvider();
        StandardQueryObject standardQueryObject = new StandardQueryObject();
        standardQueryObject.setParams(params);
        standardQueryObject.setSqlProvider(r1SqlProvider);
        standardQueryObject.setResultType(resultType);
        standardQueryObject.setHandler(handler);
        standardQueryObject.setHandlerType(handlerType);
        standardQueryObject.setHandlerParams(handlerParams);
        standardQueryObject.setExecutor(executor);
        standardQueryObject.setExecutorType(executorType);
        standardQueryObject.setExecutorParams(executorParams);
        standardQueryObject.setRoute(route);
        try {
            Object result = cardListService.getResult(standardQueryObject);
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return AjaxResult.error(e.getMessage());
        }
    }


    /**
     * 多表查询
     *
     * @param params
     * @param handler
     * @param handlerType
     * @param handlerParams
     * @param executor
     * @param executorType
     * @param executorParams
     * @param resultType
     * @param route
     * @return
     */
    @RequestMapping("/commonSelect")
    public Object commonSelect(
            @RequestParam Map<String, Object> params,
            @RequestParam(required = false) String handler, @RequestParam(defaultValue = StandardQueryObject.BEAN) String handlerType, @RequestParam(required = false) String handlerParams,
            @RequestParam(required = false) String executor, @RequestParam(defaultValue = StandardQueryObject.BEAN) String executorType, @RequestParam(required = false) String executorParams,
            @RequestParam(defaultValue = "list") String resultType, @RequestParam(required = false) String route) {
        R2SqlProvider r2SqlProvider = new R2SqlProvider();
        StandardQueryObject standardQueryObject = new StandardQueryObject();
        standardQueryObject.setParams(params);
        standardQueryObject.setSqlProvider(r2SqlProvider);
        standardQueryObject.setResultType(resultType);
        standardQueryObject.setHandler(handler);
        standardQueryObject.setHandlerType(handlerType);
        standardQueryObject.setHandlerParams(handlerParams);
        standardQueryObject.setExecutor(executor);
        standardQueryObject.setExecutorType(executorType);
        standardQueryObject.setExecutorParams(executorParams);
        standardQueryObject.setRoute(route);
        try {
            Object result = cardListService.getResult(standardQueryObject);
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return AjaxResult.error(e.getMessage());
        }
    }


}
```



这里提供了三个方法，您可以按照url路径来访问具体的功能。

方法1.根据sqlCode或者seriesCode来查询到cc_base_sql的一个具体的sql，然后执行它，返回具体的结果。

方法2和方法3，一个是单表的查询语句，一个是多表的查询语句，您仅仅需要执行要查哪个表，给予哪些条件，按照什么样的排序,就能自动生成sql执行查询。





